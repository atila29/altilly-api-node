"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * altilly API
 * Create API keys in your profile https://www.altilly.com/user/profile/api and use public API key as username and secret as password to authorize.
 *
 * OpenAPI spec version: 1.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const url = require("url");
const axios_1 = require("axios");
exports.BASE_PATH = "https://api.altilly.com/api".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace ErrorError
 */
var ErrorError;
(function (ErrorError) {
    /**
     * @export
     * @enum {string}
     */
    let MessageEnum;
    (function (MessageEnum) {
        MessageEnum["InternalServerError"] = "Internal Server Error";
        MessageEnum["GatewayTimeout"] = "Gateway Timeout";
        MessageEnum["ServiceUnavailable"] = "Service Unavailable";
        MessageEnum["SymbolNotFound"] = "Symbol not found";
        MessageEnum["AuthorisationRequired"] = "Authorisation required";
        MessageEnum["AuthorisationFailed"] = "Authorisation failed";
        MessageEnum["ValidationError"] = "Validation error";
        MessageEnum["InsufficientFunds"] = "Insufficient funds";
    })(MessageEnum = ErrorError.MessageEnum || (ErrorError.MessageEnum = {}));
})(ErrorError = exports.ErrorError || (exports.ErrorError = {}));
/**
 * AccountApi - axios parameter creator
 * @export
 */
exports.AccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This returns available trading balance / funds held for orders / pending deposits and is a little slower than the tradingbalance call
         * @summary Get detailed acccount balance information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalanceGet(options = {}) {
            const localVarPath = `/account/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get deposit crypro address
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyGet(currency, options = {}) {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency', 'Required parameter currency was null or undefined when calling accountCryptoAddressCurrencyGet.');
            }
            const localVarPath = `/account/crypto/address/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create new deposit crypro address
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyPost(currency, options = {}) {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency', 'Required parameter currency was null or undefined when calling accountCryptoAddressCurrencyPost.');
            }
            const localVarPath = `/account/crypto/address/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel / Rollback a withdrawal request.  You may also request cancellation via the website interface
         * @summary Rollback withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling accountCryptoWithdrawIdDelete.');
            }
            const localVarPath = `/account/crypto/withdraw/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Commit / Confirm the requested withdrawal if autoCommit was set to false
         * @summary Commit withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {string} confirmCode The confirmCode from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdPut(id, confirmCode, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling accountCryptoWithdrawIdPut.');
            }
            // verify required parameter 'confirmCode' is not null or undefined
            if (confirmCode === null || confirmCode === undefined) {
                throw new RequiredError('confirmCode', 'Required parameter confirmCode was null or undefined when calling accountCryptoWithdrawIdPut.');
            }
            const localVarPath = `/account/crypto/withdraw/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new url.URLSearchParams();
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (confirmCode !== undefined) {
                localVarFormParams.set('confirmCode', confirmCode);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a withdrawal of a cryptocurrency to the requested address.  Withdrawal requests submitted via the API can only be confirmed/committed via the API.
         * @summary Withdraw crypto
         * @param {string} currency
         * @param {string} amount
         * @param {string} address
         * @param {string} [paymentId]
         * @param {boolean} [includeFee] If enabled, then fee will be subtracted from amount. Otherwise, the fee is added to the amount.
         * @param {boolean} [autoCommit] If Auto commit disabled you should commit it or rollback within 1 hour. After 1 hour, the transaction will expired automatically be rolled back.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawPost(currency, amount, address, paymentId, includeFee, autoCommit, options = {}) {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency', 'Required parameter currency was null or undefined when calling accountCryptoWithdrawPost.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount', 'Required parameter amount was null or undefined when calling accountCryptoWithdrawPost.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address', 'Required parameter address was null or undefined when calling accountCryptoWithdrawPost.');
            }
            const localVarPath = `/account/crypto/withdraw`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new url.URLSearchParams();
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (currency !== undefined) {
                localVarFormParams.set('currency', currency);
            }
            if (amount !== undefined) {
                localVarFormParams.set('amount', amount);
            }
            if (address !== undefined) {
                localVarFormParams.set('address', address);
            }
            if (paymentId !== undefined) {
                localVarFormParams.set('paymentId', paymentId);
            }
            if (includeFee !== undefined) {
                localVarFormParams.set('includeFee', includeFee);
            }
            if (autoCommit !== undefined) {
                localVarFormParams.set('autoCommit', autoCommit);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account transactions (Deposits & Withdrawals)
         * @param {string} [currency]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp'} [by] Filter field
         * @param {string} [from] Datetime in iso format or timestamp in millisecond.
         * @param {string} [till] Datetime in iso format or timestamp in millisecond.
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsGet(currency, sort, by, from, till, limit, offset, options = {}) {
            const localVarPath = `/account/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (till !== undefined) {
                localVarQueryParameter['till'] = till;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account transactions by transactionId
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsTransactionIdGet(transactionId, options = {}) {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling accountTransactionsTransactionIdGet.');
            }
            const localVarPath = `/account/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountApi - functional programming interface
 * @export
 */
exports.AccountApiFp = function (configuration) {
    return {
        /**
         * This returns available trading balance / funds held for orders / pending deposits and is a little slower than the tradingbalance call
         * @summary Get detailed acccount balance information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalanceGet(options) {
            const localVarAxiosArgs = exports.AccountApiAxiosParamCreator(configuration).accountBalanceGet(options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get deposit crypro address
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyGet(currency, options) {
            const localVarAxiosArgs = exports.AccountApiAxiosParamCreator(configuration).accountCryptoAddressCurrencyGet(currency, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create new deposit crypro address
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyPost(currency, options) {
            const localVarAxiosArgs = exports.AccountApiAxiosParamCreator(configuration).accountCryptoAddressCurrencyPost(currency, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * Cancel / Rollback a withdrawal request.  You may also request cancellation via the website interface
         * @summary Rollback withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdDelete(id, options) {
            const localVarAxiosArgs = exports.AccountApiAxiosParamCreator(configuration).accountCryptoWithdrawIdDelete(id, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * Commit / Confirm the requested withdrawal if autoCommit was set to false
         * @summary Commit withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {string} confirmCode The confirmCode from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdPut(id, confirmCode, options) {
            const localVarAxiosArgs = exports.AccountApiAxiosParamCreator(configuration).accountCryptoWithdrawIdPut(id, confirmCode, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * Performs a withdrawal of a cryptocurrency to the requested address.  Withdrawal requests submitted via the API can only be confirmed/committed via the API.
         * @summary Withdraw crypto
         * @param {string} currency
         * @param {string} amount
         * @param {string} address
         * @param {string} [paymentId]
         * @param {boolean} [includeFee] If enabled, then fee will be subtracted from amount. Otherwise, the fee is added to the amount.
         * @param {boolean} [autoCommit] If Auto commit disabled you should commit it or rollback within 1 hour. After 1 hour, the transaction will expired automatically be rolled back.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawPost(currency, amount, address, paymentId, includeFee, autoCommit, options) {
            const localVarAxiosArgs = exports.AccountApiAxiosParamCreator(configuration).accountCryptoWithdrawPost(currency, amount, address, paymentId, includeFee, autoCommit, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get account transactions (Deposits & Withdrawals)
         * @param {string} [currency]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp'} [by] Filter field
         * @param {string} [from] Datetime in iso format or timestamp in millisecond.
         * @param {string} [till] Datetime in iso format or timestamp in millisecond.
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsGet(currency, sort, by, from, till, limit, offset, options) {
            const localVarAxiosArgs = exports.AccountApiAxiosParamCreator(configuration).accountTransactionsGet(currency, sort, by, from, till, limit, offset, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get account transactions by transactionId
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsTransactionIdGet(transactionId, options) {
            const localVarAxiosArgs = exports.AccountApiAxiosParamCreator(configuration).accountTransactionsTransactionIdGet(transactionId, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AccountApi - factory interface
 * @export
 */
exports.AccountApiFactory = function (configuration, basePath) {
    return {
        /**
         * This returns available trading balance / funds held for orders / pending deposits and is a little slower than the tradingbalance call
         * @summary Get detailed acccount balance information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalanceGet(options) {
            return exports.AccountApiFp(configuration).accountBalanceGet(options)(basePath);
        },
        /**
         *
         * @summary Get deposit crypro address
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyGet(currency, options) {
            return exports.AccountApiFp(configuration).accountCryptoAddressCurrencyGet(currency, options)(basePath);
        },
        /**
         *
         * @summary Create new deposit crypro address
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyPost(currency, options) {
            return exports.AccountApiFp(configuration).accountCryptoAddressCurrencyPost(currency, options)(basePath);
        },
        /**
         * Cancel / Rollback a withdrawal request.  You may also request cancellation via the website interface
         * @summary Rollback withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdDelete(id, options) {
            return exports.AccountApiFp(configuration).accountCryptoWithdrawIdDelete(id, options)(basePath);
        },
        /**
         * Commit / Confirm the requested withdrawal if autoCommit was set to false
         * @summary Commit withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {string} confirmCode The confirmCode from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdPut(id, confirmCode, options) {
            return exports.AccountApiFp(configuration).accountCryptoWithdrawIdPut(id, confirmCode, options)(basePath);
        },
        /**
         * Performs a withdrawal of a cryptocurrency to the requested address.  Withdrawal requests submitted via the API can only be confirmed/committed via the API.
         * @summary Withdraw crypto
         * @param {string} currency
         * @param {string} amount
         * @param {string} address
         * @param {string} [paymentId]
         * @param {boolean} [includeFee] If enabled, then fee will be subtracted from amount. Otherwise, the fee is added to the amount.
         * @param {boolean} [autoCommit] If Auto commit disabled you should commit it or rollback within 1 hour. After 1 hour, the transaction will expired automatically be rolled back.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawPost(currency, amount, address, paymentId, includeFee, autoCommit, options) {
            return exports.AccountApiFp(configuration).accountCryptoWithdrawPost(currency, amount, address, paymentId, includeFee, autoCommit, options)(basePath);
        },
        /**
         *
         * @summary Get account transactions (Deposits & Withdrawals)
         * @param {string} [currency]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp'} [by] Filter field
         * @param {string} [from] Datetime in iso format or timestamp in millisecond.
         * @param {string} [till] Datetime in iso format or timestamp in millisecond.
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsGet(currency, sort, by, from, till, limit, offset, options) {
            return exports.AccountApiFp(configuration).accountTransactionsGet(currency, sort, by, from, till, limit, offset, options)(basePath);
        },
        /**
         *
         * @summary Get account transactions by transactionId
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsTransactionIdGet(transactionId, options) {
            return exports.AccountApiFp(configuration).accountTransactionsTransactionIdGet(transactionId, options)(basePath);
        },
    };
};
/**
 * PublicApi - axios parameter creator
 * @export
 */
exports.PublicApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Candles
         * @param {string} symbol
         * @param {number} [limit] Number of results to receive.  Default is 100.  Use 0 to receive all available resultset.
         * @param {'30MIN' | '3HR' | '8HR' | '12HR' | '24HR'} [period] Time period between candlesticks.  Available options are 30MIN, 3HR, 8HR, 12HR, 24HR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCandlesSymbolGet(symbol, limit, period, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling publicCandlesSymbolGet.');
            }
            const localVarPath = `/public/candles/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get currency info
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyCurrencyGet(currency, options = {}) {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency', 'Required parameter currency was null or undefined when calling publicCurrencyCurrencyGet.');
            }
            const localVarPath = `/public/currency/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp
         * @summary Available Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyGet(options = {}) {
            const localVarPath = `/public/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Orderbook
         * @param {string} symbol
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicOrderbookSymbolGet(symbol, limit, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling publicOrderbookSymbolGet.');
            }
            const localVarPath = `/public/orderbook/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Simple Orderbook format as used by Bitcoincharts and Tradingview.
         * @param {string} symbol
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpleordersSymbolGet(symbol, limit, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling publicSimpleordersSymbolGet.');
            }
            const localVarPath = `/public/simpleorders/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the format used by Bitcoincharts and Tradingview.  Maximum 1000 results since the trade # \"since\" given
         * @summary A simple format of trades in the symbol as used by Bitcoincharts and Tradingview
         * @param {string} symbol
         * @param {string} [since]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpletradesSymbolGet(symbol, since, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling publicSimpletradesSymbolGet.');
            }
            const localVarPath = `/public/simpletrades/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp
         * @summary Available Currency Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolGet(options = {}) {
            const localVarPath = `/public/symbol`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get symbol info
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolSymbolGet(symbol, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling publicSymbolSymbolGet.');
            }
            const localVarPath = `/public/symbol/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Ticker endpoint returns last 24H information about of all symbol.
         * @summary Ticker list for all symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerGet(options = {}) {
            const localVarPath = `/public/ticker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Ticker endpoint returns last 24H information about symbol.
         * @summary Ticker for symbol
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerSymbolGet(symbol, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling publicTickerSymbolGet.');
            }
            const localVarPath = `/public/ticker/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Trades
         * @param {string} symbol
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling publicTradesSymbolGet.');
            }
            const localVarPath = `/public/trades/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (till !== undefined) {
                localVarQueryParameter['till'] = till;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PublicApi - functional programming interface
 * @export
 */
exports.PublicApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Candles
         * @param {string} symbol
         * @param {number} [limit] Number of results to receive.  Default is 100.  Use 0 to receive all available resultset.
         * @param {'30MIN' | '3HR' | '8HR' | '12HR' | '24HR'} [period] Time period between candlesticks.  Available options are 30MIN, 3HR, 8HR, 12HR, 24HR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCandlesSymbolGet(symbol, limit, period, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicCandlesSymbolGet(symbol, limit, period, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get currency info
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyCurrencyGet(currency, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicCurrencyCurrencyGet(currency, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp
         * @summary Available Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyGet(options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicCurrencyGet(options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Orderbook
         * @param {string} symbol
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicOrderbookSymbolGet(symbol, limit, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicOrderbookSymbolGet(symbol, limit, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Simple Orderbook format as used by Bitcoincharts and Tradingview.
         * @param {string} symbol
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpleordersSymbolGet(symbol, limit, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicSimpleordersSymbolGet(symbol, limit, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * This is the format used by Bitcoincharts and Tradingview.  Maximum 1000 results since the trade # \"since\" given
         * @summary A simple format of trades in the symbol as used by Bitcoincharts and Tradingview
         * @param {string} symbol
         * @param {string} [since]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpletradesSymbolGet(symbol, since, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicSimpletradesSymbolGet(symbol, since, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp
         * @summary Available Currency Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolGet(options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicSymbolGet(options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get symbol info
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolSymbolGet(symbol, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicSymbolSymbolGet(symbol, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * The Ticker endpoint returns last 24H information about of all symbol.
         * @summary Ticker list for all symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerGet(options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicTickerGet(options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * The Ticker endpoint returns last 24H information about symbol.
         * @summary Ticker for symbol
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerSymbolGet(symbol, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicTickerSymbolGet(symbol, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Trades
         * @param {string} symbol
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PublicApi - factory interface
 * @export
 */
exports.PublicApiFactory = function (configuration, basePath) {
    return {
        /**
         *
         * @summary Candles
         * @param {string} symbol
         * @param {number} [limit] Number of results to receive.  Default is 100.  Use 0 to receive all available resultset.
         * @param {'30MIN' | '3HR' | '8HR' | '12HR' | '24HR'} [period] Time period between candlesticks.  Available options are 30MIN, 3HR, 8HR, 12HR, 24HR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCandlesSymbolGet(symbol, limit, period, options) {
            return exports.PublicApiFp(configuration).publicCandlesSymbolGet(symbol, limit, period, options)(basePath);
        },
        /**
         *
         * @summary Get currency info
         * @param {string} currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyCurrencyGet(currency, options) {
            return exports.PublicApiFp(configuration).publicCurrencyCurrencyGet(currency, options)(basePath);
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp
         * @summary Available Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyGet(options) {
            return exports.PublicApiFp(configuration).publicCurrencyGet(options)(basePath);
        },
        /**
         *
         * @summary Orderbook
         * @param {string} symbol
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicOrderbookSymbolGet(symbol, limit, options) {
            return exports.PublicApiFp(configuration).publicOrderbookSymbolGet(symbol, limit, options)(basePath);
        },
        /**
         *
         * @summary Simple Orderbook format as used by Bitcoincharts and Tradingview.
         * @param {string} symbol
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpleordersSymbolGet(symbol, limit, options) {
            return exports.PublicApiFp(configuration).publicSimpleordersSymbolGet(symbol, limit, options)(basePath);
        },
        /**
         * This is the format used by Bitcoincharts and Tradingview.  Maximum 1000 results since the trade # \"since\" given
         * @summary A simple format of trades in the symbol as used by Bitcoincharts and Tradingview
         * @param {string} symbol
         * @param {string} [since]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpletradesSymbolGet(symbol, since, options) {
            return exports.PublicApiFp(configuration).publicSimpletradesSymbolGet(symbol, since, options)(basePath);
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp
         * @summary Available Currency Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolGet(options) {
            return exports.PublicApiFp(configuration).publicSymbolGet(options)(basePath);
        },
        /**
         *
         * @summary Get symbol info
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolSymbolGet(symbol, options) {
            return exports.PublicApiFp(configuration).publicSymbolSymbolGet(symbol, options)(basePath);
        },
        /**
         * The Ticker endpoint returns last 24H information about of all symbol.
         * @summary Ticker list for all symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerGet(options) {
            return exports.PublicApiFp(configuration).publicTickerGet(options)(basePath);
        },
        /**
         * The Ticker endpoint returns last 24H information about symbol.
         * @summary Ticker for symbol
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerSymbolGet(symbol, options) {
            return exports.PublicApiFp(configuration).publicTickerSymbolGet(symbol, options)(basePath);
        },
        /**
         *
         * @summary Trades
         * @param {string} symbol
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options) {
            return exports.PublicApiFp(configuration).publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options)(basePath);
        },
    };
};
/**
 * TradingApi - axios parameter creator
 * @export
 */
exports.TradingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancel an order by clientOrderId -or- UUID
         * @summary Cancel an order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDDelete(clientOrderIdUUID, options = {}) {
            // verify required parameter 'clientOrderIdUUID' is not null or undefined
            if (clientOrderIdUUID === null || clientOrderIdUUID === undefined) {
                throw new RequiredError('clientOrderIdUUID', 'Required parameter clientOrderIdUUID was null or undefined when calling orderClientOrderIdUUIDDelete.');
            }
            const localVarPath = `/order/{clientOrderId_UUID}`
                .replace(`{${"clientOrderId_UUID"}}`, encodeURIComponent(String(clientOrderIdUUID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single order by clientOrderId or UUID. clientOrderId is assigned by the user, UUID is assigned by the server
         * @summary Get a single order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDGet(clientOrderIdUUID, options = {}) {
            // verify required parameter 'clientOrderIdUUID' is not null or undefined
            if (clientOrderIdUUID === null || clientOrderIdUUID === undefined) {
                throw new RequiredError('clientOrderIdUUID', 'Required parameter clientOrderIdUUID was null or undefined when calling orderClientOrderIdUUIDGet.');
            }
            const localVarPath = `/order/{clientOrderId_UUID}`
                .replace(`{${"clientOrderId_UUID"}}`, encodeURIComponent(String(clientOrderIdUUID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a group of orders.  Enter market symbol to cancel all open orders in a single market.  Leave symbol empty to cancel all orders in all markets.
         * @summary Cancel all open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete(symbol, options = {}) {
            const localVarPath = `/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new url.URLSearchParams();
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (symbol !== undefined) {
                localVarFormParams.set('symbol', symbol);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of your currently open orders.
         * @summary List your current open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGet(symbol, options = {}) {
            const localVarPath = `/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create new order
         * @param {string} symbol
         * @param {string} side
         * @param {string} quantity
         * @param {string} [clientOrderId]
         * @param {string} [type] Order type.  See https://www.altilly.com/page/orderoptions
         * @param {string} [timeInForce] Time in force
         * @param {string} [price]
         * @param {string} [stopPrice] Used for stopMarket and stopLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {string} [tpPrice] Used for tpMarket and tpLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {any} [expireTime]
         * @param {boolean} [strictValidate] Strict validate amount and price precision without truncation.  Setting true will return an error if your quantity/price doesn&#39;t match increment/tick size.  Default false will truncate values to allowed number of decimal places.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(symbol, side, quantity, clientOrderId, type, timeInForce, price, stopPrice, tpPrice, expireTime, strictValidate, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling orderPost.');
            }
            // verify required parameter 'side' is not null or undefined
            if (side === null || side === undefined) {
                throw new RequiredError('side', 'Required parameter side was null or undefined when calling orderPost.');
            }
            // verify required parameter 'quantity' is not null or undefined
            if (quantity === null || quantity === undefined) {
                throw new RequiredError('quantity', 'Required parameter quantity was null or undefined when calling orderPost.');
            }
            const localVarPath = `/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new url.URLSearchParams();
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (clientOrderId !== undefined) {
                localVarFormParams.set('clientOrderId', clientOrderId);
            }
            if (symbol !== undefined) {
                localVarFormParams.set('symbol', symbol);
            }
            if (side !== undefined) {
                localVarFormParams.set('side', side);
            }
            if (type !== undefined) {
                localVarFormParams.set('type', type);
            }
            if (timeInForce !== undefined) {
                localVarFormParams.set('timeInForce', timeInForce);
            }
            if (quantity !== undefined) {
                localVarFormParams.set('quantity', quantity);
            }
            if (price !== undefined) {
                localVarFormParams.set('price', price);
            }
            if (stopPrice !== undefined) {
                localVarFormParams.set('stopPrice', stopPrice);
            }
            if (tpPrice !== undefined) {
                localVarFormParams.set('tpPrice', tpPrice);
            }
            if (expireTime !== undefined) {
                localVarFormParams.set('expireTime', expireTime);
            }
            if (strictValidate !== undefined) {
                localVarFormParams.set('strictValidate', strictValidate);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns available trading balance for each currency
         * @summary Get basic trading balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingBalanceGet(options = {}) {
            const localVarPath = `/trading/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get trading fee rate
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingFeeSymbolGet(symbol, options = {}) {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling tradingFeeSymbolGet.');
            }
            const localVarPath = `/trading/fee/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TradingApi - functional programming interface
 * @export
 */
exports.TradingApiFp = function (configuration) {
    return {
        /**
         * Cancel an order by clientOrderId -or- UUID
         * @summary Cancel an order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDDelete(clientOrderIdUUID, options) {
            const localVarAxiosArgs = exports.TradingApiAxiosParamCreator(configuration).orderClientOrderIdUUIDDelete(clientOrderIdUUID, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * Get a single order by clientOrderId or UUID. clientOrderId is assigned by the user, UUID is assigned by the server
         * @summary Get a single order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDGet(clientOrderIdUUID, options) {
            const localVarAxiosArgs = exports.TradingApiAxiosParamCreator(configuration).orderClientOrderIdUUIDGet(clientOrderIdUUID, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * Cancel a group of orders.  Enter market symbol to cancel all open orders in a single market.  Leave symbol empty to cancel all orders in all markets.
         * @summary Cancel all open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete(symbol, options) {
            const localVarAxiosArgs = exports.TradingApiAxiosParamCreator(configuration).orderDelete(symbol, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * List of your currently open orders.
         * @summary List your current open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGet(symbol, options) {
            const localVarAxiosArgs = exports.TradingApiAxiosParamCreator(configuration).orderGet(symbol, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create new order
         * @param {string} symbol
         * @param {string} side
         * @param {string} quantity
         * @param {string} [clientOrderId]
         * @param {string} [type] Order type.  See https://www.altilly.com/page/orderoptions
         * @param {string} [timeInForce] Time in force
         * @param {string} [price]
         * @param {string} [stopPrice] Used for stopMarket and stopLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {string} [tpPrice] Used for tpMarket and tpLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {any} [expireTime]
         * @param {boolean} [strictValidate] Strict validate amount and price precision without truncation.  Setting true will return an error if your quantity/price doesn&#39;t match increment/tick size.  Default false will truncate values to allowed number of decimal places.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(symbol, side, quantity, clientOrderId, type, timeInForce, price, stopPrice, tpPrice, expireTime, strictValidate, options) {
            const localVarAxiosArgs = exports.TradingApiAxiosParamCreator(configuration).orderPost(symbol, side, quantity, clientOrderId, type, timeInForce, price, stopPrice, tpPrice, expireTime, strictValidate, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         * This returns available trading balance for each currency
         * @summary Get basic trading balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingBalanceGet(options) {
            const localVarAxiosArgs = exports.TradingApiAxiosParamCreator(configuration).tradingBalanceGet(options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get trading fee rate
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingFeeSymbolGet(symbol, options) {
            const localVarAxiosArgs = exports.TradingApiAxiosParamCreator(configuration).tradingFeeSymbolGet(symbol, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * TradingApi - factory interface
 * @export
 */
exports.TradingApiFactory = function (configuration, basePath) {
    return {
        /**
         * Cancel an order by clientOrderId -or- UUID
         * @summary Cancel an order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDDelete(clientOrderIdUUID, options) {
            return exports.TradingApiFp(configuration).orderClientOrderIdUUIDDelete(clientOrderIdUUID, options)(basePath);
        },
        /**
         * Get a single order by clientOrderId or UUID. clientOrderId is assigned by the user, UUID is assigned by the server
         * @summary Get a single order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDGet(clientOrderIdUUID, options) {
            return exports.TradingApiFp(configuration).orderClientOrderIdUUIDGet(clientOrderIdUUID, options)(basePath);
        },
        /**
         * Cancel a group of orders.  Enter market symbol to cancel all open orders in a single market.  Leave symbol empty to cancel all orders in all markets.
         * @summary Cancel all open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete(symbol, options) {
            return exports.TradingApiFp(configuration).orderDelete(symbol, options)(basePath);
        },
        /**
         * List of your currently open orders.
         * @summary List your current open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGet(symbol, options) {
            return exports.TradingApiFp(configuration).orderGet(symbol, options)(basePath);
        },
        /**
         *
         * @summary Create new order
         * @param {string} symbol
         * @param {string} side
         * @param {string} quantity
         * @param {string} [clientOrderId]
         * @param {string} [type] Order type.  See https://www.altilly.com/page/orderoptions
         * @param {string} [timeInForce] Time in force
         * @param {string} [price]
         * @param {string} [stopPrice] Used for stopMarket and stopLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {string} [tpPrice] Used for tpMarket and tpLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {any} [expireTime]
         * @param {boolean} [strictValidate] Strict validate amount and price precision without truncation.  Setting true will return an error if your quantity/price doesn&#39;t match increment/tick size.  Default false will truncate values to allowed number of decimal places.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(symbol, side, quantity, clientOrderId, type, timeInForce, price, stopPrice, tpPrice, expireTime, strictValidate, options) {
            return exports.TradingApiFp(configuration).orderPost(symbol, side, quantity, clientOrderId, type, timeInForce, price, stopPrice, tpPrice, expireTime, strictValidate, options)(basePath);
        },
        /**
         * This returns available trading balance for each currency
         * @summary Get basic trading balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingBalanceGet(options) {
            return exports.TradingApiFp(configuration).tradingBalanceGet(options)(basePath);
        },
        /**
         *
         * @summary Get trading fee rate
         * @param {string} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingFeeSymbolGet(symbol, options) {
            return exports.TradingApiFp(configuration).tradingFeeSymbolGet(symbol, options)(basePath);
        },
    };
};
/**
 * TradingHistoryApi - axios parameter creator
 * @export
 */
exports.TradingHistoryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get your historical orders - filled or cancelled
         * @param {'filled' | 'cancelled'} historytype History Type
         * @param {string} [symbol]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {string} [clientOrderId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyOrderGet(historytype, symbol, sort, by, from, till, limit, offset, clientOrderId, options = {}) {
            // verify required parameter 'historytype' is not null or undefined
            if (historytype === null || historytype === undefined) {
                throw new RequiredError('historytype', 'Required parameter historytype was null or undefined when calling historyOrderGet.');
            }
            const localVarPath = `/history/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (historytype !== undefined) {
                localVarQueryParameter['historytype'] = historytype;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (till !== undefined) {
                localVarQueryParameter['till'] = till;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (clientOrderId !== undefined) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get your historical trades by specified clientOrderId -or- order UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesClientOrderIdUUIDGet(clientOrderIdUUID, options = {}) {
            // verify required parameter 'clientOrderIdUUID' is not null or undefined
            if (clientOrderIdUUID === null || clientOrderIdUUID === undefined) {
                throw new RequiredError('clientOrderIdUUID', 'Required parameter clientOrderIdUUID was null or undefined when calling historyTradesClientOrderIdUUIDGet.');
            }
            const localVarPath = `/history/trades/{clientOrderId_UUID}`
                .replace(`{${"clientOrderId_UUID"}}`, encodeURIComponent(String(clientOrderIdUUID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get your historical trades
         * @param {string} [symbol]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesGet(symbol, sort, by, from, till, limit, offset, options = {}) {
            const localVarPath = `/history/trades`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (till !== undefined) {
                localVarQueryParameter['till'] = till;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TradingHistoryApi - functional programming interface
 * @export
 */
exports.TradingHistoryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get your historical orders - filled or cancelled
         * @param {'filled' | 'cancelled'} historytype History Type
         * @param {string} [symbol]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {string} [clientOrderId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyOrderGet(historytype, symbol, sort, by, from, till, limit, offset, clientOrderId, options) {
            const localVarAxiosArgs = exports.TradingHistoryApiAxiosParamCreator(configuration).historyOrderGet(historytype, symbol, sort, by, from, till, limit, offset, clientOrderId, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get your historical trades by specified clientOrderId -or- order UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesClientOrderIdUUIDGet(clientOrderIdUUID, options) {
            const localVarAxiosArgs = exports.TradingHistoryApiAxiosParamCreator(configuration).historyTradesClientOrderIdUUIDGet(clientOrderIdUUID, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get your historical trades
         * @param {string} [symbol]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesGet(symbol, sort, by, from, till, limit, offset, options) {
            const localVarAxiosArgs = exports.TradingHistoryApiAxiosParamCreator(configuration).historyTradesGet(symbol, sort, by, from, till, limit, offset, options);
            return (basePath = exports.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios_1.default.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * TradingHistoryApi - factory interface
 * @export
 */
exports.TradingHistoryApiFactory = function (configuration, basePath) {
    return {
        /**
         *
         * @summary Get your historical orders - filled or cancelled
         * @param {'filled' | 'cancelled'} historytype History Type
         * @param {string} [symbol]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {string} [clientOrderId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyOrderGet(historytype, symbol, sort, by, from, till, limit, offset, clientOrderId, options) {
            return exports.TradingHistoryApiFp(configuration).historyOrderGet(historytype, symbol, sort, by, from, till, limit, offset, clientOrderId, options)(basePath);
        },
        /**
         *
         * @summary Get your historical trades by specified clientOrderId -or- order UUID
         * @param {string} clientOrderIdUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesClientOrderIdUUIDGet(clientOrderIdUUID, options) {
            return exports.TradingHistoryApiFp(configuration).historyTradesClientOrderIdUUIDGet(clientOrderIdUUID, options)(basePath);
        },
        /**
         *
         * @summary Get your historical trades
         * @param {string} [symbol]
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesGet(symbol, sort, by, from, till, limit, offset, options) {
            return exports.TradingHistoryApiFp(configuration).historyTradesGet(symbol, sort, by, from, till, limit, offset, options)(basePath);
        },
    };
};
//# sourceMappingURL=api.js.map