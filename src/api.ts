
import { Transaction } from "./model/Transaction";

import { TradingFee } from "./model/TradingFee";

import { Trade } from "./model/Trade";

import { Ticker } from "./model/Ticker";

import { Symbol } from "./model/Symbol";

import { SimpleTrade } from "./model/SimpleTrade";

import { SimpleOrder } from "./model/SimpleOrder";

import { PublicTrade } from "./model/PublicTrade";

import { Orderbook } from "./model/Orderbook";

import { Order } from "./model/Order";

import { Currency } from "./model/Currency";

import { Candle } from "./model/Candle";

import { BasicBalance } from "./model/BasicBalance";


// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * altilly API
 * Create API keys in your profile https://www.altilly.com/user/profile/api and use public API key as username and secret as password to authorize. 
 *
 * OpenAPI spec version: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import axios, { AxiosPromise } from 'axios';
import { DetailedBalance } from "./model/DetailedBalance";
import { Address } from "./model/Address";
import { WithdrawConfirm } from "./WithdrawConfirm";

const BASE_PATH = "https://api.altilly.com/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ErrorError
 */
export interface ErrorError {
    /**
     * 
     * @type {number}
     * @memberof ErrorError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorError
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorError
     */
    message?: ErrorError.MessageEnum;
}

/**
 * @export
 * @namespace ErrorError
 */
export namespace ErrorError {
    /**
     * @export
     * @enum {string}
     */
    export enum MessageEnum {
        InternalServerError = 'Internal Server Error',
        GatewayTimeout = 'Gateway Timeout',
        ServiceUnavailable = 'Service Unavailable',
        SymbolNotFound = 'Symbol not found',
        AuthorisationRequired = 'Authorisation required',
        AuthorisationFailed = 'Authorisation failed',
        ValidationError = 'Validation error',
        InsufficientFunds = 'Insufficient funds'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    totalAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    receiveAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    confirmCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    committed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    paymentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    autoCommit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {ErrorError}
     * @memberof ModelError
     */
    error?: ErrorError;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns available trading balance / funds held for orders / pending deposits and is a little slower than the tradingbalance call
         * @summary Get detailed acccount balance information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalanceGet(options: any = {}): RequestArgs {
            const localVarPath = `/account/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get deposit crypro address
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyGet(currency: string, options: any = {}): RequestArgs {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling accountCryptoAddressCurrencyGet.');
            }
            const localVarPath = `/account/crypto/address/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new deposit crypro address
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyPost(currency: string, options: any = {}): RequestArgs {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling accountCryptoAddressCurrencyPost.');
            }
            const localVarPath = `/account/crypto/address/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel / Rollback a withdrawal request.  You may also request cancellation via the website interface
         * @summary Rollback withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdDelete(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling accountCryptoWithdrawIdDelete.');
            }
            const localVarPath = `/account/crypto/withdraw/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Commit / Confirm the requested withdrawal if autoCommit was set to false
         * @summary Commit withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {string} confirmCode The confirmCode from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdPut(id: string, confirmCode: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling accountCryptoWithdrawIdPut.');
            }
            // verify required parameter 'confirmCode' is not null or undefined
            if (confirmCode === null || confirmCode === undefined) {
                throw new RequiredError('confirmCode','Required parameter confirmCode was null or undefined when calling accountCryptoWithdrawIdPut.');
            }
            const localVarPath = `/account/crypto/withdraw/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (confirmCode !== undefined) {
                localVarFormParams.set('confirmCode', confirmCode as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a withdrawal of a cryptocurrency to the requested address.  Withdrawal requests submitted via the API can only be confirmed/committed via the API.
         * @summary Withdraw crypto
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} address 
         * @param {string} [paymentId] 
         * @param {boolean} [includeFee] If enabled, then fee will be subtracted from amount. Otherwise, the fee is added to the amount.
         * @param {boolean} [autoCommit] If Auto commit disabled you should commit it or rollback within 1 hour. After 1 hour, the transaction will expired automatically be rolled back.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawPost(currency: string, amount: string, address: string, paymentId?: string, includeFee?: boolean, autoCommit?: boolean, options: any = {}): RequestArgs {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling accountCryptoWithdrawPost.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling accountCryptoWithdrawPost.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling accountCryptoWithdrawPost.');
            }
            const localVarPath = `/account/crypto/withdraw`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (currency !== undefined) {
                localVarFormParams.set('currency', currency as any);
            }

            if (amount !== undefined) {
                localVarFormParams.set('amount', amount as any);
            }

            if (address !== undefined) {
                localVarFormParams.set('address', address as any);
            }

            if (paymentId !== undefined) {
                localVarFormParams.set('paymentId', paymentId as any);
            }

            if (includeFee !== undefined) {
                localVarFormParams.set('includeFee', includeFee as any);
            }

            if (autoCommit !== undefined) {
                localVarFormParams.set('autoCommit', autoCommit as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account transactions (Deposits & Withdrawals)
         * @param {string} [currency] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp'} [by] Filter field
         * @param {string} [from] Datetime in iso format or timestamp in millisecond.
         * @param {string} [till] Datetime in iso format or timestamp in millisecond.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsGet(currency?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp', from?: string, till?: string, limit?: number, offset?: number, options: any = {}): RequestArgs {
            const localVarPath = `/account/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account transactions by transactionId
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsTransactionIdGet(transactionId: string, options: any = {}): RequestArgs {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling accountTransactionsTransactionIdGet.');
            }
            const localVarPath = `/account/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This returns available trading balance / funds held for orders / pending deposits and is a little slower than the tradingbalance call
         * @summary Get detailed acccount balance information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalanceGet(options?: any): (basePath?: string) => AxiosPromise<Array<DetailedBalance>> {
            const localVarAxiosArgs = AccountApiAxiosParamCreator(configuration).accountBalanceGet(options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get deposit crypro address
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyGet(currency: string, options?: any): (basePath?: string) => AxiosPromise<Address> {
            const localVarAxiosArgs = AccountApiAxiosParamCreator(configuration).accountCryptoAddressCurrencyGet(currency, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create new deposit crypro address
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyPost(currency: string, options?: any): (basePath?: string) => AxiosPromise<Address> {
            const localVarAxiosArgs = AccountApiAxiosParamCreator(configuration).accountCryptoAddressCurrencyPost(currency, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Cancel / Rollback a withdrawal request.  You may also request cancellation via the website interface
         * @summary Rollback withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdDelete(id: string, options?: any): (basePath?: string) => AxiosPromise<WithdrawConfirm> {
            const localVarAxiosArgs = AccountApiAxiosParamCreator(configuration).accountCryptoWithdrawIdDelete(id, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Commit / Confirm the requested withdrawal if autoCommit was set to false
         * @summary Commit withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {string} confirmCode The confirmCode from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdPut(id: string, confirmCode: string, options?: any): (basePath?: string) => AxiosPromise<WithdrawConfirm> {
            const localVarAxiosArgs = AccountApiAxiosParamCreator(configuration).accountCryptoWithdrawIdPut(id, confirmCode, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Performs a withdrawal of a cryptocurrency to the requested address.  Withdrawal requests submitted via the API can only be confirmed/committed via the API.
         * @summary Withdraw crypto
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} address 
         * @param {string} [paymentId] 
         * @param {boolean} [includeFee] If enabled, then fee will be subtracted from amount. Otherwise, the fee is added to the amount.
         * @param {boolean} [autoCommit] If Auto commit disabled you should commit it or rollback within 1 hour. After 1 hour, the transaction will expired automatically be rolled back.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawPost(currency: string, amount: string, address: string, paymentId?: string, includeFee?: boolean, autoCommit?: boolean, options?: any): (basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = AccountApiAxiosParamCreator(configuration).accountCryptoWithdrawPost(currency, amount, address, paymentId, includeFee, autoCommit, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get account transactions (Deposits & Withdrawals)
         * @param {string} [currency] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp'} [by] Filter field
         * @param {string} [from] Datetime in iso format or timestamp in millisecond.
         * @param {string} [till] Datetime in iso format or timestamp in millisecond.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsGet(currency?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp', from?: string, till?: string, limit?: number, offset?: number, options?: any): (basePath?: string) => AxiosPromise<Array<Transaction>> {
            const localVarAxiosArgs = AccountApiAxiosParamCreator(configuration).accountTransactionsGet(currency, sort, by, from, till, limit, offset, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get account transactions by transactionId
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsTransactionIdGet(transactionId: string, options?: any): (basePath?: string) => AxiosPromise<Array<Transaction>> {
            const localVarAxiosArgs = AccountApiAxiosParamCreator(configuration).accountTransactionsTransactionIdGet(transactionId, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string) {
    return {
        /**
         * This returns available trading balance / funds held for orders / pending deposits and is a little slower than the tradingbalance call
         * @summary Get detailed acccount balance information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalanceGet(options?: any) {
            return AccountApiFp(configuration).accountBalanceGet(options)(basePath);
        },
        /**
         * 
         * @summary Get deposit crypro address
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyGet(currency: string, options?: any) {
            return AccountApiFp(configuration).accountCryptoAddressCurrencyGet(currency, options)(basePath);
        },
        /**
         * 
         * @summary Create new deposit crypro address
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoAddressCurrencyPost(currency: string, options?: any) {
            return AccountApiFp(configuration).accountCryptoAddressCurrencyPost(currency, options)(basePath);
        },
        /**
         * Cancel / Rollback a withdrawal request.  You may also request cancellation via the website interface
         * @summary Rollback withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdDelete(id: string, options?: any) {
            return AccountApiFp(configuration).accountCryptoWithdrawIdDelete(id, options)(basePath);
        },
        /**
         * Commit / Confirm the requested withdrawal if autoCommit was set to false
         * @summary Commit withdraw crypto
         * @param {string} id The ID of the transaction from the withdraw request
         * @param {string} confirmCode The confirmCode from the withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawIdPut(id: string, confirmCode: string, options?: any) {
            return AccountApiFp(configuration).accountCryptoWithdrawIdPut(id, confirmCode, options)(basePath);
        },
        /**
         * Performs a withdrawal of a cryptocurrency to the requested address.  Withdrawal requests submitted via the API can only be confirmed/committed via the API.
         * @summary Withdraw crypto
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} address 
         * @param {string} [paymentId] 
         * @param {boolean} [includeFee] If enabled, then fee will be subtracted from amount. Otherwise, the fee is added to the amount.
         * @param {boolean} [autoCommit] If Auto commit disabled you should commit it or rollback within 1 hour. After 1 hour, the transaction will expired automatically be rolled back.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCryptoWithdrawPost(currency: string, amount: string, address: string, paymentId?: string, includeFee?: boolean, autoCommit?: boolean, options?: any) {
            return AccountApiFp(configuration).accountCryptoWithdrawPost(currency, amount, address, paymentId, includeFee, autoCommit, options)(basePath);
        },
        /**
         * 
         * @summary Get account transactions (Deposits & Withdrawals)
         * @param {string} [currency] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp'} [by] Filter field
         * @param {string} [from] Datetime in iso format or timestamp in millisecond.
         * @param {string} [till] Datetime in iso format or timestamp in millisecond.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsGet(currency?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp', from?: string, till?: string, limit?: number, offset?: number, options?: any) {
            return AccountApiFp(configuration).accountTransactionsGet(currency, sort, by, from, till, limit, offset, options)(basePath);
        },
        /**
         * 
         * @summary Get account transactions by transactionId
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsTransactionIdGet(transactionId: string, options?: any) {
            return AccountApiFp(configuration).accountTransactionsTransactionIdGet(transactionId, options)(basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * This returns available trading balance / funds held for orders / pending deposits and is a little slower than the tradingbalance call
     * @summary Get detailed acccount balance information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountBalanceGet(options?: any) {
        return AccountApiFp(this.configuration).accountBalanceGet(options)(this.basePath);
    }

    /**
     * 
     * @summary Get deposit crypro address
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountCryptoAddressCurrencyGet(currency: string, options?: any) {
        return AccountApiFp(this.configuration).accountCryptoAddressCurrencyGet(currency, options)(this.basePath);
    }

    /**
     * 
     * @summary Create new deposit crypro address
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountCryptoAddressCurrencyPost(currency: string, options?: any) {
        return AccountApiFp(this.configuration).accountCryptoAddressCurrencyPost(currency, options)(this.basePath);
    }

    /**
     * Cancel / Rollback a withdrawal request.  You may also request cancellation via the website interface
     * @summary Rollback withdraw crypto
     * @param {string} id The ID of the transaction from the withdraw request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountCryptoWithdrawIdDelete(id: string, options?: any) {
        return AccountApiFp(this.configuration).accountCryptoWithdrawIdDelete(id, options)(this.basePath);
    }

    /**
     * Commit / Confirm the requested withdrawal if autoCommit was set to false
     * @summary Commit withdraw crypto
     * @param {string} id The ID of the transaction from the withdraw request
     * @param {string} confirmCode The confirmCode from the withdraw request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountCryptoWithdrawIdPut(id: string, confirmCode: string, options?: any) {
        return AccountApiFp(this.configuration).accountCryptoWithdrawIdPut(id, confirmCode, options)(this.basePath);
    }

    /**
     * Performs a withdrawal of a cryptocurrency to the requested address.  Withdrawal requests submitted via the API can only be confirmed/committed via the API.
     * @summary Withdraw crypto
     * @param {string} currency 
     * @param {string} amount 
     * @param {string} address 
     * @param {string} [paymentId] 
     * @param {boolean} [includeFee] If enabled, then fee will be subtracted from amount. Otherwise, the fee is added to the amount.
     * @param {boolean} [autoCommit] If Auto commit disabled you should commit it or rollback within 1 hour. After 1 hour, the transaction will expired automatically be rolled back.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountCryptoWithdrawPost(currency: string, amount: string, address: string, paymentId?: string, includeFee?: boolean, autoCommit?: boolean, options?: any) {
        return AccountApiFp(this.configuration).accountCryptoWithdrawPost(currency, amount, address, paymentId, includeFee, autoCommit, options)(this.basePath);
    }

    /**
     * 
     * @summary Get account transactions (Deposits & Withdrawals)
     * @param {string} [currency] 
     * @param {'DESC' | 'ASC'} [sort] Sort direction
     * @param {'timestamp'} [by] Filter field
     * @param {string} [from] Datetime in iso format or timestamp in millisecond.
     * @param {string} [till] Datetime in iso format or timestamp in millisecond.
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountTransactionsGet(currency?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp', from?: string, till?: string, limit?: number, offset?: number, options?: any) {
        return AccountApiFp(this.configuration).accountTransactionsGet(currency, sort, by, from, till, limit, offset, options)(this.basePath);
    }

    /**
     * 
     * @summary Get account transactions by transactionId
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountTransactionsTransactionIdGet(transactionId: string, options?: any) {
        return AccountApiFp(this.configuration).accountTransactionsTransactionIdGet(transactionId, options)(this.basePath);
    }

}

/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Candles
         * @param {string} symbol 
         * @param {number} [limit] Number of results to receive.  Default is 100.  Use 0 to receive all available resultset.
         * @param {'30MIN' | '3HR' | '8HR' | '12HR' | '24HR'} [period] Time period between candlesticks.  Available options are 30MIN, 3HR, 8HR, 12HR, 24HR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCandlesSymbolGet(symbol: string, limit?: number, period?: '30MIN' | '3HR' | '8HR' | '12HR' | '24HR', options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicCandlesSymbolGet.');
            }
            const localVarPath = `/public/candles/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get currency info
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyCurrencyGet(currency: string, options: any = {}): RequestArgs {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling publicCurrencyCurrencyGet.');
            }
            const localVarPath = `/public/currency/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp 
         * @summary Available Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyGet(options: any = {}): RequestArgs {
            const localVarPath = `/public/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Orderbook
         * @param {string} symbol 
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicOrderbookSymbolGet(symbol: string, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicOrderbookSymbolGet.');
            }
            const localVarPath = `/public/orderbook/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simple Orderbook format as used by Bitcoincharts and Tradingview.
         * @param {string} symbol 
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpleordersSymbolGet(symbol: string, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicSimpleordersSymbolGet.');
            }
            const localVarPath = `/public/simpleorders/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the format used by Bitcoincharts and Tradingview.  Maximum 1000 results since the trade # \"since\" given 
         * @summary A simple format of trades in the symbol as used by Bitcoincharts and Tradingview
         * @param {string} symbol 
         * @param {string} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpletradesSymbolGet(symbol: string, since?: string, options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicSimpletradesSymbolGet.');
            }
            const localVarPath = `/public/simpletrades/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp 
         * @summary Available Currency Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolGet(options: any = {}): RequestArgs {
            const localVarPath = `/public/symbol`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get symbol info
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolSymbolGet(symbol: string, options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicSymbolSymbolGet.');
            }
            const localVarPath = `/public/symbol/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Ticker endpoint returns last 24H information about of all symbol. 
         * @summary Ticker list for all symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerGet(options: any = {}): RequestArgs {
            const localVarPath = `/public/ticker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Ticker endpoint returns last 24H information about symbol. 
         * @summary Ticker for symbol
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerSymbolGet(symbol: string, options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicTickerSymbolGet.');
            }
            const localVarPath = `/public/ticker/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trades
         * @param {string} symbol 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTradesSymbolGet(symbol: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicTradesSymbolGet.');
            }
            const localVarPath = `/public/trades/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Candles
         * @param {string} symbol 
         * @param {number} [limit] Number of results to receive.  Default is 100.  Use 0 to receive all available resultset.
         * @param {'30MIN' | '3HR' | '8HR' | '12HR' | '24HR'} [period] Time period between candlesticks.  Available options are 30MIN, 3HR, 8HR, 12HR, 24HR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCandlesSymbolGet(symbol: string, limit?: number, period?: '30MIN' | '3HR' | '8HR' | '12HR' | '24HR', options?: any): (basePath?: string) => AxiosPromise<Array<Candle>> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicCandlesSymbolGet(symbol, limit, period, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get currency info
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyCurrencyGet(currency: string, options?: any): (basePath?: string) => AxiosPromise<Currency> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicCurrencyCurrencyGet(currency, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp 
         * @summary Available Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyGet(options?: any): (basePath?: string) => AxiosPromise<Array<Currency>> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicCurrencyGet(options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Orderbook
         * @param {string} symbol 
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicOrderbookSymbolGet(symbol: string, limit?: number, options?: any): (basePath?: string) => AxiosPromise<Orderbook> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicOrderbookSymbolGet(symbol, limit, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Simple Orderbook format as used by Bitcoincharts and Tradingview.
         * @param {string} symbol 
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpleordersSymbolGet(symbol: string, limit?: number, options?: any): (basePath?: string) => AxiosPromise<SimpleOrder> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicSimpleordersSymbolGet(symbol, limit, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * This is the format used by Bitcoincharts and Tradingview.  Maximum 1000 results since the trade # \"since\" given 
         * @summary A simple format of trades in the symbol as used by Bitcoincharts and Tradingview
         * @param {string} symbol 
         * @param {string} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpletradesSymbolGet(symbol: string, since?: string, options?: any): (basePath?: string) => AxiosPromise<SimpleTrade> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicSimpletradesSymbolGet(symbol, since, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp 
         * @summary Available Currency Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolGet(options?: any): (basePath?: string) => AxiosPromise<Array<Symbol>> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicSymbolGet(options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get symbol info
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolSymbolGet(symbol: string, options?: any): (basePath?: string) => AxiosPromise<Symbol> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicSymbolSymbolGet(symbol, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * The Ticker endpoint returns last 24H information about of all symbol. 
         * @summary Ticker list for all symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerGet(options?: any): (basePath?: string) => AxiosPromise<Array<Ticker>> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicTickerGet(options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * The Ticker endpoint returns last 24H information about symbol. 
         * @summary Ticker for symbol
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerSymbolGet(symbol: string, options?: any): (basePath?: string) => AxiosPromise<Ticker> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicTickerSymbolGet(symbol, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Trades
         * @param {string} symbol 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTradesSymbolGet(symbol: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, options?: any): (basePath?: string) => AxiosPromise<Array<PublicTrade>> {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string) {
    return {
        /**
         * 
         * @summary Candles
         * @param {string} symbol 
         * @param {number} [limit] Number of results to receive.  Default is 100.  Use 0 to receive all available resultset.
         * @param {'30MIN' | '3HR' | '8HR' | '12HR' | '24HR'} [period] Time period between candlesticks.  Available options are 30MIN, 3HR, 8HR, 12HR, 24HR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCandlesSymbolGet(symbol: string, limit?: number, period?: '30MIN' | '3HR' | '8HR' | '12HR' | '24HR', options?: any) {
            return PublicApiFp(configuration).publicCandlesSymbolGet(symbol, limit, period, options)(basePath);
        },
        /**
         * 
         * @summary Get currency info
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyCurrencyGet(currency: string, options?: any) {
            return PublicApiFp(configuration).publicCurrencyCurrencyGet(currency, options)(basePath);
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp 
         * @summary Available Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyGet(options?: any) {
            return PublicApiFp(configuration).publicCurrencyGet(options)(basePath);
        },
        /**
         * 
         * @summary Orderbook
         * @param {string} symbol 
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicOrderbookSymbolGet(symbol: string, limit?: number, options?: any) {
            return PublicApiFp(configuration).publicOrderbookSymbolGet(symbol, limit, options)(basePath);
        },
        /**
         * 
         * @summary Simple Orderbook format as used by Bitcoincharts and Tradingview.
         * @param {string} symbol 
         * @param {number} [limit] 0 - full orderbook otherwise number of levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpleordersSymbolGet(symbol: string, limit?: number, options?: any) {
            return PublicApiFp(configuration).publicSimpleordersSymbolGet(symbol, limit, options)(basePath);
        },
        /**
         * This is the format used by Bitcoincharts and Tradingview.  Maximum 1000 results since the trade # \"since\" given 
         * @summary A simple format of trades in the symbol as used by Bitcoincharts and Tradingview
         * @param {string} symbol 
         * @param {string} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSimpletradesSymbolGet(symbol: string, since?: string, options?: any) {
            return PublicApiFp(configuration).publicSimpletradesSymbolGet(symbol, since, options)(basePath);
        },
        /**
         * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp 
         * @summary Available Currency Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolGet(options?: any) {
            return PublicApiFp(configuration).publicSymbolGet(options)(basePath);
        },
        /**
         * 
         * @summary Get symbol info
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolSymbolGet(symbol: string, options?: any) {
            return PublicApiFp(configuration).publicSymbolSymbolGet(symbol, options)(basePath);
        },
        /**
         * The Ticker endpoint returns last 24H information about of all symbol. 
         * @summary Ticker list for all symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerGet(options?: any) {
            return PublicApiFp(configuration).publicTickerGet(options)(basePath);
        },
        /**
         * The Ticker endpoint returns last 24H information about symbol. 
         * @summary Ticker for symbol
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerSymbolGet(symbol: string, options?: any) {
            return PublicApiFp(configuration).publicTickerSymbolGet(symbol, options)(basePath);
        },
        /**
         * 
         * @summary Trades
         * @param {string} symbol 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTradesSymbolGet(symbol: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, options?: any) {
            return PublicApiFp(configuration).publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options)(basePath);
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 
     * @summary Candles
     * @param {string} symbol 
     * @param {number} [limit] Number of results to receive.  Default is 100.  Use 0 to receive all available resultset.
     * @param {'30MIN' | '3HR' | '8HR' | '12HR' | '24HR'} [period] Time period between candlesticks.  Available options are 30MIN, 3HR, 8HR, 12HR, 24HR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicCandlesSymbolGet(symbol: string, limit?: number, period?: '30MIN' | '3HR' | '8HR' | '12HR' | '24HR', options?: any) {
        return PublicApiFp(this.configuration).publicCandlesSymbolGet(symbol, limit, period, options)(this.basePath);
    }

    /**
     * 
     * @summary Get currency info
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicCurrencyCurrencyGet(currency: string, options?: any) {
        return PublicApiFp(this.configuration).publicCurrencyCurrencyGet(currency, options)(this.basePath);
    }

    /**
     * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp 
     * @summary Available Currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicCurrencyGet(options?: any) {
        return PublicApiFp(this.configuration).publicCurrencyGet(options)(this.basePath);
    }

    /**
     * 
     * @summary Orderbook
     * @param {string} symbol 
     * @param {number} [limit] 0 - full orderbook otherwise number of levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicOrderbookSymbolGet(symbol: string, limit?: number, options?: any) {
        return PublicApiFp(this.configuration).publicOrderbookSymbolGet(symbol, limit, options)(this.basePath);
    }

    /**
     * 
     * @summary Simple Orderbook format as used by Bitcoincharts and Tradingview.
     * @param {string} symbol 
     * @param {number} [limit] 0 - full orderbook otherwise number of levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicSimpleordersSymbolGet(symbol: string, limit?: number, options?: any) {
        return PublicApiFp(this.configuration).publicSimpleordersSymbolGet(symbol, limit, options)(this.basePath);
    }

    /**
     * This is the format used by Bitcoincharts and Tradingview.  Maximum 1000 results since the trade # \"since\" given 
     * @summary A simple format of trades in the symbol as used by Bitcoincharts and Tradingview
     * @param {string} symbol 
     * @param {string} [since] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicSimpletradesSymbolGet(symbol: string, since?: string, options?: any) {
        return PublicApiFp(this.configuration).publicSimpletradesSymbolGet(symbol, since, options)(this.basePath);
    }

    /**
     * Get list of avialable Symbols (Currency Pairs). You can read more info at http://www.investopedia.com/terms/c/currencypair.asp 
     * @summary Available Currency Symbols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicSymbolGet(options?: any) {
        return PublicApiFp(this.configuration).publicSymbolGet(options)(this.basePath);
    }

    /**
     * 
     * @summary Get symbol info
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicSymbolSymbolGet(symbol: string, options?: any) {
        return PublicApiFp(this.configuration).publicSymbolSymbolGet(symbol, options)(this.basePath);
    }

    /**
     * The Ticker endpoint returns last 24H information about of all symbol. 
     * @summary Ticker list for all symbols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicTickerGet(options?: any) {
        return PublicApiFp(this.configuration).publicTickerGet(options)(this.basePath);
    }

    /**
     * The Ticker endpoint returns last 24H information about symbol. 
     * @summary Ticker for symbol
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicTickerSymbolGet(symbol: string, options?: any) {
        return PublicApiFp(this.configuration).publicTickerSymbolGet(symbol, options)(this.basePath);
    }

    /**
     * 
     * @summary Trades
     * @param {string} symbol 
     * @param {'DESC' | 'ASC'} [sort] Sort direction
     * @param {'timestamp' | 'id'} [by] Filter field
     * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
     * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
     * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicTradesSymbolGet(symbol: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, options?: any) {
        return PublicApiFp(this.configuration).publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options)(this.basePath);
    }

}

/**
 * TradingApi - axios parameter creator
 * @export
 */
export const TradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel an order by clientOrderId -or- UUID 
         * @summary Cancel an order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDDelete(clientOrderIdUUID: string, options: any = {}): RequestArgs {
            // verify required parameter 'clientOrderIdUUID' is not null or undefined
            if (clientOrderIdUUID === null || clientOrderIdUUID === undefined) {
                throw new RequiredError('clientOrderIdUUID','Required parameter clientOrderIdUUID was null or undefined when calling orderClientOrderIdUUIDDelete.');
            }
            const localVarPath = `/order/{clientOrderId_UUID}`
                .replace(`{${"clientOrderId_UUID"}}`, encodeURIComponent(String(clientOrderIdUUID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single order by clientOrderId or UUID. clientOrderId is assigned by the user, UUID is assigned by the server 
         * @summary Get a single order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDGet(clientOrderIdUUID: string, options: any = {}): RequestArgs {
            // verify required parameter 'clientOrderIdUUID' is not null or undefined
            if (clientOrderIdUUID === null || clientOrderIdUUID === undefined) {
                throw new RequiredError('clientOrderIdUUID','Required parameter clientOrderIdUUID was null or undefined when calling orderClientOrderIdUUIDGet.');
            }
            const localVarPath = `/order/{clientOrderId_UUID}`
                .replace(`{${"clientOrderId_UUID"}}`, encodeURIComponent(String(clientOrderIdUUID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a group of orders.  Enter market symbol to cancel all open orders in a single market.  Leave symbol empty to cancel all orders in all markets. 
         * @summary Cancel all open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete(symbol?: string, options: any = {}): RequestArgs {
            const localVarPath = `/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (symbol !== undefined) {
                localVarFormParams.set('symbol', symbol as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of your currently open orders.
         * @summary List your current open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGet(symbol?: string, options: any = {}): RequestArgs {
            const localVarPath = `/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new order
         * @param {string} symbol 
         * @param {string} side 
         * @param {string} quantity 
         * @param {string} [clientOrderId] 
         * @param {string} [type] Order type.  See https://www.altilly.com/page/orderoptions
         * @param {string} [timeInForce] Time in force
         * @param {string} [price] 
         * @param {string} [stopPrice] Used for stopMarket and stopLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {string} [tpPrice] Used for tpMarket and tpLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {any} [expireTime] 
         * @param {boolean} [strictValidate] Strict validate amount and price precision without truncation.  Setting true will return an error if your quantity/price doesn&#39;t match increment/tick size.  Default false will truncate values to allowed number of decimal places.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(symbol: string, side: string, quantity: string, clientOrderId?: string, type?: string, timeInForce?: string, price?: string, stopPrice?: string, tpPrice?: string, expireTime?: any, strictValidate?: boolean, options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling orderPost.');
            }
            // verify required parameter 'side' is not null or undefined
            if (side === null || side === undefined) {
                throw new RequiredError('side','Required parameter side was null or undefined when calling orderPost.');
            }
            // verify required parameter 'quantity' is not null or undefined
            if (quantity === null || quantity === undefined) {
                throw new RequiredError('quantity','Required parameter quantity was null or undefined when calling orderPost.');
            }
            const localVarPath = `/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (clientOrderId !== undefined) {
                localVarFormParams.set('clientOrderId', clientOrderId as any);
            }

            if (symbol !== undefined) {
                localVarFormParams.set('symbol', symbol as any);
            }

            if (side !== undefined) {
                localVarFormParams.set('side', side as any);
            }

            if (type !== undefined) {
                localVarFormParams.set('type', type as any);
            }

            if (timeInForce !== undefined) {
                localVarFormParams.set('timeInForce', timeInForce as any);
            }

            if (quantity !== undefined) {
                localVarFormParams.set('quantity', quantity as any);
            }

            if (price !== undefined) {
                localVarFormParams.set('price', price as any);
            }

            if (stopPrice !== undefined) {
                localVarFormParams.set('stopPrice', stopPrice as any);
            }

            if (tpPrice !== undefined) {
                localVarFormParams.set('tpPrice', tpPrice as any);
            }

            if (expireTime !== undefined) {
                localVarFormParams.set('expireTime', expireTime as any);
            }

            if (strictValidate !== undefined) {
                localVarFormParams.set('strictValidate', strictValidate as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns available trading balance for each currency
         * @summary Get basic trading balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingBalanceGet(options: any = {}): RequestArgs {
            const localVarPath = `/trading/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get trading fee rate
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingFeeSymbolGet(symbol: string, options: any = {}): RequestArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling tradingFeeSymbolGet.');
            }
            const localVarPath = `/trading/fee/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Cancel an order by clientOrderId -or- UUID 
         * @summary Cancel an order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDDelete(clientOrderIdUUID: string, options?: any): (basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = TradingApiAxiosParamCreator(configuration).orderClientOrderIdUUIDDelete(clientOrderIdUUID, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Get a single order by clientOrderId or UUID. clientOrderId is assigned by the user, UUID is assigned by the server 
         * @summary Get a single order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDGet(clientOrderIdUUID: string, options?: any): (basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = TradingApiAxiosParamCreator(configuration).orderClientOrderIdUUIDGet(clientOrderIdUUID, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Cancel a group of orders.  Enter market symbol to cancel all open orders in a single market.  Leave symbol empty to cancel all orders in all markets. 
         * @summary Cancel all open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete(symbol?: string, options?: any): (basePath?: string) => AxiosPromise<Array<Order>> {
            const localVarAxiosArgs = TradingApiAxiosParamCreator(configuration).orderDelete(symbol, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * List of your currently open orders.
         * @summary List your current open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGet(symbol?: string, options?: any): (basePath?: string) => AxiosPromise<Array<Order>> {
            const localVarAxiosArgs = TradingApiAxiosParamCreator(configuration).orderGet(symbol, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create new order
         * @param {string} symbol 
         * @param {string} side 
         * @param {string} quantity 
         * @param {string} [clientOrderId] 
         * @param {string} [type] Order type.  See https://www.altilly.com/page/orderoptions
         * @param {string} [timeInForce] Time in force
         * @param {string} [price] 
         * @param {string} [stopPrice] Used for stopMarket and stopLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {string} [tpPrice] Used for tpMarket and tpLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {any} [expireTime] 
         * @param {boolean} [strictValidate] Strict validate amount and price precision without truncation.  Setting true will return an error if your quantity/price doesn&#39;t match increment/tick size.  Default false will truncate values to allowed number of decimal places.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(symbol: string, side: string, quantity: string, clientOrderId?: string, type?: string, timeInForce?: string, price?: string, stopPrice?: string, tpPrice?: string, expireTime?: any, strictValidate?: boolean, options?: any): (basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = TradingApiAxiosParamCreator(configuration).orderPost(symbol, side, quantity, clientOrderId, type, timeInForce, price, stopPrice, tpPrice, expireTime, strictValidate, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * This returns available trading balance for each currency
         * @summary Get basic trading balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingBalanceGet(options?: any): (basePath?: string) => AxiosPromise<Array<BasicBalance>> {
            const localVarAxiosArgs = TradingApiAxiosParamCreator(configuration).tradingBalanceGet(options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get trading fee rate
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingFeeSymbolGet(symbol: string, options?: any): (basePath?: string) => AxiosPromise<TradingFee> {
            const localVarAxiosArgs = TradingApiAxiosParamCreator(configuration).tradingFeeSymbolGet(symbol, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (configuration?: Configuration, basePath?: string) {
    return {
        /**
         * Cancel an order by clientOrderId -or- UUID 
         * @summary Cancel an order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDDelete(clientOrderIdUUID: string, options?: any) {
            return TradingApiFp(configuration).orderClientOrderIdUUIDDelete(clientOrderIdUUID, options)(basePath);
        },
        /**
         * Get a single order by clientOrderId or UUID. clientOrderId is assigned by the user, UUID is assigned by the server 
         * @summary Get a single order by clientOrderId -or- UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClientOrderIdUUIDGet(clientOrderIdUUID: string, options?: any) {
            return TradingApiFp(configuration).orderClientOrderIdUUIDGet(clientOrderIdUUID, options)(basePath);
        },
        /**
         * Cancel a group of orders.  Enter market symbol to cancel all open orders in a single market.  Leave symbol empty to cancel all orders in all markets. 
         * @summary Cancel all open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete(symbol?: string, options?: any) {
            return TradingApiFp(configuration).orderDelete(symbol, options)(basePath);
        },
        /**
         * List of your currently open orders.
         * @summary List your current open orders
         * @param {string} [symbol] Leave blank for all markets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGet(symbol?: string, options?: any) {
            return TradingApiFp(configuration).orderGet(symbol, options)(basePath);
        },
        /**
         * 
         * @summary Create new order
         * @param {string} symbol 
         * @param {string} side 
         * @param {string} quantity 
         * @param {string} [clientOrderId] 
         * @param {string} [type] Order type.  See https://www.altilly.com/page/orderoptions
         * @param {string} [timeInForce] Time in force
         * @param {string} [price] 
         * @param {string} [stopPrice] Used for stopMarket and stopLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {string} [tpPrice] Used for tpMarket and tpLimit order types.  See https://www.altilly.com/page/orderoptions
         * @param {any} [expireTime] 
         * @param {boolean} [strictValidate] Strict validate amount and price precision without truncation.  Setting true will return an error if your quantity/price doesn&#39;t match increment/tick size.  Default false will truncate values to allowed number of decimal places.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(symbol: string, side: string, quantity: string, clientOrderId?: string, type?: string, timeInForce?: string, price?: string, stopPrice?: string, tpPrice?: string, expireTime?: any, strictValidate?: boolean, options?: any) {
            return TradingApiFp(configuration).orderPost(symbol, side, quantity, clientOrderId, type, timeInForce, price, stopPrice, tpPrice, expireTime, strictValidate, options)(basePath);
        },
        /**
         * This returns available trading balance for each currency
         * @summary Get basic trading balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingBalanceGet(options?: any) {
            return TradingApiFp(configuration).tradingBalanceGet(options)(basePath);
        },
        /**
         * 
         * @summary Get trading fee rate
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingFeeSymbolGet(symbol: string, options?: any) {
            return TradingApiFp(configuration).tradingFeeSymbolGet(symbol, options)(basePath);
        },
    };
};

/**
 * TradingApi - object-oriented interface
 * @export
 * @class TradingApi
 * @extends {BaseAPI}
 */
export class TradingApi extends BaseAPI {
    /**
     * Cancel an order by clientOrderId -or- UUID 
     * @summary Cancel an order by clientOrderId -or- UUID
     * @param {string} clientOrderIdUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public orderClientOrderIdUUIDDelete(clientOrderIdUUID: string, options?: any) {
        return TradingApiFp(this.configuration).orderClientOrderIdUUIDDelete(clientOrderIdUUID, options)(this.basePath);
    }

    /**
     * Get a single order by clientOrderId or UUID. clientOrderId is assigned by the user, UUID is assigned by the server 
     * @summary Get a single order by clientOrderId -or- UUID
     * @param {string} clientOrderIdUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public orderClientOrderIdUUIDGet(clientOrderIdUUID: string, options?: any) {
        return TradingApiFp(this.configuration).orderClientOrderIdUUIDGet(clientOrderIdUUID, options)(this.basePath);
    }

    /**
     * Cancel a group of orders.  Enter market symbol to cancel all open orders in a single market.  Leave symbol empty to cancel all orders in all markets. 
     * @summary Cancel all open orders
     * @param {string} [symbol] Leave blank for all markets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public orderDelete(symbol?: string, options?: any) {
        return TradingApiFp(this.configuration).orderDelete(symbol, options)(this.basePath);
    }

    /**
     * List of your currently open orders.
     * @summary List your current open orders
     * @param {string} [symbol] Leave blank for all markets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public orderGet(symbol?: string, options?: any) {
        return TradingApiFp(this.configuration).orderGet(symbol, options)(this.basePath);
    }

    /**
     * 
     * @summary Create new order
     * @param {string} symbol 
     * @param {string} side 
     * @param {string} quantity 
     * @param {string} [clientOrderId] 
     * @param {string} [type] Order type.  See https://www.altilly.com/page/orderoptions
     * @param {string} [timeInForce] Time in force
     * @param {string} [price] 
     * @param {string} [stopPrice] Used for stopMarket and stopLimit order types.  See https://www.altilly.com/page/orderoptions
     * @param {string} [tpPrice] Used for tpMarket and tpLimit order types.  See https://www.altilly.com/page/orderoptions
     * @param {any} [expireTime] 
     * @param {boolean} [strictValidate] Strict validate amount and price precision without truncation.  Setting true will return an error if your quantity/price doesn&#39;t match increment/tick size.  Default false will truncate values to allowed number of decimal places.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public orderPost(symbol: string, side: string, quantity: string, clientOrderId?: string, type?: string, timeInForce?: string, price?: string, stopPrice?: string, tpPrice?: string, expireTime?: any, strictValidate?: boolean, options?: any) {
        return TradingApiFp(this.configuration).orderPost(symbol, side, quantity, clientOrderId, type, timeInForce, price, stopPrice, tpPrice, expireTime, strictValidate, options)(this.basePath);
    }

    /**
     * This returns available trading balance for each currency
     * @summary Get basic trading balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingBalanceGet(options?: any) {
        return TradingApiFp(this.configuration).tradingBalanceGet(options)(this.basePath);
    }

    /**
     * 
     * @summary Get trading fee rate
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingFeeSymbolGet(symbol: string, options?: any) {
        return TradingApiFp(this.configuration).tradingFeeSymbolGet(symbol, options)(this.basePath);
    }

}

/**
 * TradingHistoryApi - axios parameter creator
 * @export
 */
export const TradingHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get your historical orders - filled or cancelled
         * @param {'filled' | 'cancelled'} historytype History Type
         * @param {string} [symbol] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [clientOrderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyOrderGet(historytype: 'filled' | 'cancelled', symbol?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, clientOrderId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'historytype' is not null or undefined
            if (historytype === null || historytype === undefined) {
                throw new RequiredError('historytype','Required parameter historytype was null or undefined when calling historyOrderGet.');
            }
            const localVarPath = `/history/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (historytype !== undefined) {
                localVarQueryParameter['historytype'] = historytype;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (clientOrderId !== undefined) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get your historical trades by specified clientOrderId -or- order UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesClientOrderIdUUIDGet(clientOrderIdUUID: string, options: any = {}): RequestArgs {
            // verify required parameter 'clientOrderIdUUID' is not null or undefined
            if (clientOrderIdUUID === null || clientOrderIdUUID === undefined) {
                throw new RequiredError('clientOrderIdUUID','Required parameter clientOrderIdUUID was null or undefined when calling historyTradesClientOrderIdUUIDGet.');
            }
            const localVarPath = `/history/trades/{clientOrderId_UUID}`
                .replace(`{${"clientOrderId_UUID"}}`, encodeURIComponent(String(clientOrderIdUUID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get your historical trades
         * @param {string} [symbol] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesGet(symbol?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, options: any = {}): RequestArgs {
            const localVarPath = `/history/trades`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingHistoryApi - functional programming interface
 * @export
 */
export const TradingHistoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get your historical orders - filled or cancelled
         * @param {'filled' | 'cancelled'} historytype History Type
         * @param {string} [symbol] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [clientOrderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyOrderGet(historytype: 'filled' | 'cancelled', symbol?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, clientOrderId?: string, options?: any): (basePath?: string) => AxiosPromise<Array<Order>> {
            const localVarAxiosArgs = TradingHistoryApiAxiosParamCreator(configuration).historyOrderGet(historytype, symbol, sort, by, from, till, limit, offset, clientOrderId, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get your historical trades by specified clientOrderId -or- order UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesClientOrderIdUUIDGet(clientOrderIdUUID: string, options?: any): (basePath?: string) => AxiosPromise<Array<Trade>> {
            const localVarAxiosArgs = TradingHistoryApiAxiosParamCreator(configuration).historyTradesClientOrderIdUUIDGet(clientOrderIdUUID, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get your historical trades
         * @param {string} [symbol] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesGet(symbol?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, options?: any): (basePath?: string) => AxiosPromise<Array<Trade>> {
            const localVarAxiosArgs = TradingHistoryApiAxiosParamCreator(configuration).historyTradesGet(symbol, sort, by, from, till, limit, offset, options);
            return (basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TradingHistoryApi - factory interface
 * @export
 */
export const TradingHistoryApiFactory = function (configuration?: Configuration, basePath?: string) {
    return {
        /**
         * 
         * @summary Get your historical orders - filled or cancelled
         * @param {'filled' | 'cancelled'} historytype History Type
         * @param {string} [symbol] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [clientOrderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyOrderGet(historytype: 'filled' | 'cancelled', symbol?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, clientOrderId?: string, options?: any) {
            return TradingHistoryApiFp(configuration).historyOrderGet(historytype, symbol, sort, by, from, till, limit, offset, clientOrderId, options)(basePath);
        },
        /**
         * 
         * @summary Get your historical trades by specified clientOrderId -or- order UUID
         * @param {string} clientOrderIdUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesClientOrderIdUUIDGet(clientOrderIdUUID: string, options?: any) {
            return TradingHistoryApiFp(configuration).historyTradesClientOrderIdUUIDGet(clientOrderIdUUID, options)(basePath);
        },
        /**
         * 
         * @summary Get your historical trades
         * @param {string} [symbol] 
         * @param {'DESC' | 'ASC'} [sort] Sort direction
         * @param {'timestamp' | 'id'} [by] Filter field
         * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
         * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTradesGet(symbol?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, options?: any) {
            return TradingHistoryApiFp(configuration).historyTradesGet(symbol, sort, by, from, till, limit, offset, options)(basePath);
        },
    };
};

/**
 * TradingHistoryApi - object-oriented interface
 * @export
 * @class TradingHistoryApi
 * @extends {BaseAPI}
 */
export class TradingHistoryApi extends BaseAPI {
    /**
     * 
     * @summary Get your historical orders - filled or cancelled
     * @param {'filled' | 'cancelled'} historytype History Type
     * @param {string} [symbol] 
     * @param {'DESC' | 'ASC'} [sort] Sort direction
     * @param {'timestamp' | 'id'} [by] Filter field
     * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
     * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise order id
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [clientOrderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingHistoryApi
     */
    public historyOrderGet(historytype: 'filled' | 'cancelled', symbol?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, clientOrderId?: string, options?: any) {
        return TradingHistoryApiFp(this.configuration).historyOrderGet(historytype, symbol, sort, by, from, till, limit, offset, clientOrderId, options)(this.basePath);
    }

    /**
     * 
     * @summary Get your historical trades by specified clientOrderId -or- order UUID
     * @param {string} clientOrderIdUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingHistoryApi
     */
    public historyTradesClientOrderIdUUIDGet(clientOrderIdUUID: string, options?: any) {
        return TradingHistoryApiFp(this.configuration).historyTradesClientOrderIdUUIDGet(clientOrderIdUUID, options)(this.basePath);
    }

    /**
     * 
     * @summary Get your historical trades
     * @param {string} [symbol] 
     * @param {'DESC' | 'ASC'} [sort] Sort direction
     * @param {'timestamp' | 'id'} [by] Filter field
     * @param {string} [from] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
     * @param {string} [till] If filter by timestamp, then datetime in iso format or timestamp in millisecond otherwise trade id
     * @param {number} [limit] Default 100.  Minimum value 1, Maximum value 1000
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingHistoryApi
     */
    public historyTradesGet(symbol?: string, sort?: 'DESC' | 'ASC', by?: 'timestamp' | 'id', from?: string, till?: string, limit?: number, offset?: number, options?: any) {
        return TradingHistoryApiFp(this.configuration).historyTradesGet(symbol, sort, by, from, till, limit, offset, options)(this.basePath);
    }

}